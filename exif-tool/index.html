<!doctype html>
<html lang="en">
<head>
  <!-- AdSense (async; no fixed ad slots here => no CLS) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6216304334889617" crossorigin="anonymous"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>EXIF Tool — Cleaner, Hidden Data Extractor & Secret Embedder (Stego PNG) | UpTools</title>
  <meta name="description" content="EXIF Tool: extract EXIF, XMP, IPTC, ICC, JPEG comments, PNG/WebP chunks & trailing bytes. Clean metadata and optionally embed/extract secrets (LSB stego, PNG tEXt, PNG trailer). AES-GCM optional. 100% local." />
  <meta name="keywords" content="exif tool, exif cleaner, image metadata viewer, xmp, iptc, icc, png text chunks, itxt, ztxt, webp riff chunks, steganography, hide secret in image, lsb stego, png text chunk" />
  <meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1" />
  <meta name="theme-color" content="#0a1b0f" />
  <link rel="canonical" href="https://www.uptools.in/exif-tool/" />

  <!-- Open Graph / Twitter -->
  <meta property="og:title" content="EXIF Tool — Cleaner, Hidden Data Extractor & Secret Embedder (Stego PNG)" />
  <meta property="og:description" content="View & remove hidden image data (EXIF/XMP/IPTC/ICC/PNG/WebP), then optionally embed/extract secrets locally (AES-GCM optional). Free & private." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.uptools.in/exif-tool/" />
  <meta property="og:site_name" content="UpTools" />
  <meta property="og:image" content="https://www.uptools.in/assets/og/exif-tool.png" />
  <meta name="twitter:card" content="summary_large_image" />

  <!-- Icons -->
  <link rel="icon" sizes="50x50" type="image/svg+xml" href="/assets/logo/uptools-logo.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/logo/uptools-logo.svg" />

  <!-- JSON-LD: Breadcrumbs -->
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[
    {"@type":"ListItem","position":1,"name":"Home","item":"https://www.uptools.in/"},
    {"@type":"ListItem","position":2,"name":"Tools","item":"https://www.uptools.in/#tools"},
    {"@type":"ListItem","position":3,"name":"EXIF Tool","item":"https://www.uptools.in/exif-tool/"}
  ]}
  </script>

  <!-- JSON-LD: Software + FAQ -->
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"SoftwareApplication","name":"EXIF Tool","applicationCategory":"UtilitiesApplication","operatingSystem":"Any","url":"https://www.uptools.in/exif-tool/","description":"Extract, audit and remove hidden image data; optionally embed/extract secrets (LSB, PNG tEXt, PNG trailer) with optional AES-GCM, all locally.","offers":{"@type":"Offer","price":"0","priceCurrency":"INR"}}
  </script>
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"FAQPage","mainEntity":[
    {"@type":"Question","name":"Does this upload my images?","acceptedAnswer":{"@type":"Answer","text":"No. Everything runs in your browser. Images, secrets and wordlists never leave your device."}},
    {"@type":"Question","name":"Will cleaning remove metadata?","acceptedAnswer":{"@type":"Answer","text":"We re-encode via Canvas to strip EXIF/XMP/IPTC/ICC and comments; PNG/WebP chunks are removed by re-encode. Pixels preserved for PNG; JPEG/WebP recompress."}},
    {"@type":"Question","name":"Is embedding secrets legal?","acceptedAnswer":{"@type":"Answer","text":"Use on your own images for lawful purposes (e.g., watermarking or private notes). Social apps may strip or recompress images, removing embedded data."}}
  ]}
  </script>

  <!-- Minimal libs -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <script defer src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js" crossorigin="anonymous"></script>

  <!-- Page theme (neon green) + improved uploader styles -->
  <style>
    :root{ --accent:#22c55e; --accent-2:#16a34a; --bg1:#07140e; --bg2:#0b1711; --muted:#9bb3a2; }
    .bg-net{position:fixed;inset:0;z-index:-1;pointer-events:none;background:
      radial-gradient(900px 600px at 12% -10%, rgba(34,197,94,.16), transparent 50%),
      radial-gradient(900px 600px at 110% 10%, rgba(22,163,74,.12), transparent 50%),
      linear-gradient(135deg, var(--bg1), var(--bg2));
    }
    .bg-net .ping{position:absolute;width:220px;height:220px;border-radius:50%;
      border:2px solid color-mix(in oklab,var(--accent) 55%,transparent);
      box-shadow:0 0 18px color-mix(in oklab,var(--accent) 40%,transparent);
      animation:r 6s infinite ease-in-out;opacity:.12}
    .bg-net .ping:nth-child(1){top:12%;left:8%;animation-delay:0s}
    .bg-net .ping:nth-child(2){top:62%;right:14%;animation-delay:1.2s}
    .bg-net .ping:nth-child(3){top:28%;right:35%;animation-delay:2.1s}
    @keyframes r{0%{transform:scale(.6);opacity:.18}50%{transform:scale(1.15);opacity:.10}100%{transform:scale(1.6);opacity:.06}}

    /* Layout */
    .panel{display:grid;grid-template-columns:1.15fr 1fr;gap:12px;align-items:start}
    @media (max-width: 960px){ .panel{grid-template-columns:1fr} }
    .preview-wrap{display:flex;gap:10px}
    .preview-box{flex:1;min-height:260px;background:#0a1224;border:1px solid color-mix(in oklab,var(--accent) 25%, #223);border-radius:12px;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
    .preview-box:focus{outline:2px solid var(--accent)}
    .dz-overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.25);backdrop-filter:saturate(130%) blur(2px)}
    .preview-box.drag .dz-overlay{display:flex}
    .preview-box img{max-width:100%;max-height:100%;object-fit:contain}
    .scroll{max-height:50vh; overflow:auto}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; font-size:12px;line-height:1.4}
    .kv .row{display:flex; justify-content:space-between; gap:10px; padding:4px 0; border-bottom:1px dotted #163}
    .kv .row:last-child{border-bottom:0}
    .chip-badge{display:inline-block;padding:2px 6px;border:1px solid color-mix(in oklab,var(--accent) 40%, #223);border-radius:999px;font-size:12px;margin-left:6px}
    .hint{font-size:12px;color:var(--muted)}
    .hidden{display:none!important}
    .danger{color:#ffb4b4}
    .sticky-controls{position:sticky; top:8px}
    .btn.small{padding:6px 10px;font-size:12px}

    /* Improved uploader */
    .visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .uploader{border:1px dashed color-mix(in oklab,var(--accent) 35%, #223);border-radius:12px;padding:10px;background:#0a1224}
    .file-cta{display:flex;align-items:center;justify-content:center;gap:8px;width:100%;height:40px;border-radius:10px;border:1px solid color-mix(in oklab,var(--accent) 45%, #223);background:linear-gradient(180deg, rgba(34,197,94,.12), rgba(34,197,94,.06));cursor:pointer;transition:transform .06s ease, box-shadow .2s ease}
    .file-cta:hover{box-shadow:0 0 0 2px rgba(34,197,94,.25) inset}
    .file-cta:active{transform:translateY(1px)}
    .file-cta svg{width:18px;height:18px;display:block}
    .file-meta{display:flex;align-items:center;justify-content:space-between;margin-top:8px;font-size:12px;color:var(--muted);min-height:18px}
    .file-actions{display:flex;gap:6px;margin-top:8px}
  </style>

  <!-- Common site CSS -->
  <link rel="preload" href="/style.css?v=1.1.0" as="style">
  <link rel="stylesheet" href="/style.css?v=1.1.0" media="print" onload="this.media='all'">
  <noscript><link rel="stylesheet" href="/style.css?v=1.1.0"></noscript>
</head>

  <body>
  <!-- small fixed -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:500px;height:50px"
       data-ad-client="ca-pub-6216304334889617"
       data-ad-slot="9810172647"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <div class="bg-net" aria-hidden="true"><i class="ping"></i><i class="ping"></i><i class="ping"></i></div>

  <!-- Header -->
  <header class="site" role="banner">
    <div class="header-inner">
      <a class="brand" href="/" aria-label="UpTools Home">
        <img src="/assets/logo/uptools-logo.svg" alt="UpTools logo" width="28" height="28" loading="eager">
        <b>UpTools</b>
      </a>
      <nav class="nav-links" aria-label="Primary">
        <a href="/#tools">Tools</a>
        <a href="/image-tool/">Image Tools</a>
        <a href="/image-converter/">Image Converter</a>
        <a aria-current="page" href="/exif-tool/">EXIF Tool</a>
      </nav>
    </div>
  </header>

  <main class="wrap" id="main">
    <!-- Breadcrumbs -->
    <nav class="note small" aria-label="Breadcrumb">
      <a href="/">Home</a> › <a href="/#tools">Tools</a> › <span aria-current="page">EXIF Tool</span>
    </nav>

    <!-- Hero -->
    <div class="hero neon" style="margin-top:10px">
      <img class="hero-logo" src="/assets/logo/uptools-logo.svg" alt="UpTools shield" width="28" height="28" loading="lazy">
      <div>
        <h1>EXIF Tool</h1>
        <p class="note">View & remove EXIF/XMP/IPTC/ICC + PNG/WebP chunks • Embed/Extract secrets (LSB, PNG tEXt, PNG trailer • AES-GCM optional)</p>
      </div>
      <div id="live" class="note small" aria-live="polite"></div>
    </div>

    <!-- Page Bookmarks -->
    <nav class="chips" aria-label="On this page" style="margin:8px 0 16px">
      <a class="pill" href="#inspector">Inspector</a>
      <a class="pill" href="#cleaner">Cleaner</a>
      <a class="pill" href="#stego">Secret Embed/Extract</a>
      <a class="pill" href="#video">Video</a>
      <a class="pill" href="#faq">FAQ</a>
    </nav>

    <section class="panel">
      <!-- LEFT: Upload + Inspector -->
      <article class="card" id="inspector" aria-labelledby="insp-title">
        <div class="tool-header" style="margin-bottom:8px">
          <div class="tool-icon">🔍</div>
          <div>
            <h2 id="insp-title" style="margin:0">Inspector (Hidden Data)</h2>
            <p class="note" style="margin:2px 0 0">Drop an image, <kbd>Ctrl/⌘+V</kbd> to paste, or use the button. 100% local parsing.</p>
          </div>
        </div>

        <div class="preview-wrap">
          <div class="preview-box" id="dropzone" tabindex="0" aria-label="Drop image here">
            <div class="dz-overlay">Drop image</div>
            <img id="preview" alt="Preview of uploaded image" width="320" height="240">
          </div>

          <!-- Improved uploader -->
          <div class="sticky-controls" style="width:280px">
            <div class="uploader">
              <input id="file" name="file" type="file" class="visually-hidden" accept="image/*" capture="environment" aria-describedby="fileHelp">
              <label for="file" class="file-cta" role="button">
                <!-- inline icon -->
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path fill="currentColor" d="M12 16a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm7-9h-2.2l-1.2-1.6A2 2 0 0 0 13.8 4H10.2a2 2 0 0 0-1.8 1.4L7.2 7H5a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2Z"/>
                </svg>
                <span><b>Choose image</b></span>
              </label>
              <div class="file-meta" id="fileMeta">No file selected</div>
              <div class="file-actions">
                <button id="changeFile" class="btn small" type="button" aria-label="Change image">Change</button>
                <button id="removeFile" class="btn small secondary" type="button" aria-label="Remove image">Remove</button>
              </div>
              <p id="fileHelp" class="hint" style="margin-top:6px">Supports PNG, JPEG, WebP, HEIC (render depends on browser). On mobile, tap to use camera.</p>
            </div>

            <div class="kv" style="margin-top:10px">
              <div class="row"><span>Format</span><span class="amount" id="fmt">—</span></div>
              <div class="row"><span>Dimensions</span><span class="amount" id="dim">—</span></div>
              <div class="row"><span>File size</span><span class="amount" id="size">—</span></div>
            </div>

            <div class="chips" style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn sm" id="exportReport" type="button">Export Report (JSON)</button>
              <button class="btn sm secondary" id="copyReport" type="button">Copy Report</button>
              <button class="btn sm ghost" id="clearAll" type="button">Clear</button>
            </div>
            <div id="flags" class="note small" style="margin-top:8px"></div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px">
          <div class="card neon">
            <strong>EXIF / XMP / IPTC / ICC</strong>
            <pre id="exifOut" class="mono scroll" aria-label="EXIF/XMP output">{}</pre>
          </div>
          <div class="card neon">
            <strong>Container Chunks & Trailing Data</strong>
            <pre id="chunksOut" class="mono scroll" aria-label="Container & chunk output">[]</pre>
          </div>
        </div>
      </article>

      <!-- RIGHT: Cleaner + Stego -->
      <article class="card" id="cleaner" aria-labelledby="clean-title">
        <div class="tool-header" style="margin-bottom:8px">
          <div class="tool-icon">🧹</div>
          <div>
            <h2 id="clean-title" style="margin:0">Cleaner (Strip Metadata)</h2>
            <p class="note" style="margin:2px 0 0">Re-encode via Canvas to remove metadata. PNG keeps pixels; JPEG/WebP recompress.</p>
          </div>
        </div>

        <label class="label" for="formatOut">Output</label>
        <select id="formatOut" class="input">
          <option value="image/png">PNG (lossless, best for stego)</option>
          <option value="image/jpeg">JPEG (quality control)</option>
          <option value="image/webp">WebP</option>
        </select>

        <div id="jpegQWrap" class="hidden">
          <label class="label" for="jpegQ">JPEG Quality</label>
          <input id="jpegQ" class="input" type="range" min="0.5" max="0.95" step="0.05" value="0.9">
        </div>

        <div class="result neon" style="margin-top:8px;padding:8px">
          <div class="row"><span>Estimated clean size</span> <span class="amount" id="cleanSize">—</span></div>
        </div>

        <div class="chips" style="margin-top:8px">
          <button class="btn sm" id="cleanBtn" type="button">Clean & Download</button>
          <button class="btn sm secondary" id="copyCanvas" type="button">Copy Clean Image</button>
          <button class="btn sm ghost" id="previewClean" type="button">Preview Clean</button>
        </div>

        <hr class="divider" style="margin:12px 0">

        <div id="stego" aria-labelledby="stego-title">
          <div class="tool-header" style="margin-bottom:8px">
            <div class="tool-icon">🕵️</div>
            <div>
              <h2 id="stego-title" style="margin:0">Secret Embed / Extract (Local)</h2>
              <p class="note" style="margin:2px 0 0">Modes: <span class="chip-badge">Pixel-LSB</span> · <span class="chip-badge">PNG tEXt</span> · <span class="chip-badge">PNG Trailer</span>. Optional AES-GCM encryption.</p>
            </div>
          </div>

          <label class="label" for="stegoMode">Mode</label>
          <select id="stegoMode" class="input">
            <option value="lsb">Pixel-LSB (text, PNG only)</option>
            <option value="pngtext">PNG tEXt (text)</option>
            <option value="pngtrail">PNG Trailer (file/text)</option>
          </select>

          <div id="stegoTextWrap">
            <label class="label" for="secret">Secret Text</label>
            <textarea id="secret" class="input" placeholder="Write your secret message..." rows="3" maxlength="500000"></textarea>
          </div>

          <div id="fileWrap" class="hidden">
            <label class="label" for="secretFile">Secret File (optional)</label>
            <input id="secretFile" type="file" class="input">
            <p class="hint">If chosen, the file is embedded in the PNG trailer. Without a file, your text is embedded.</p>
          </div>

          <div class="grid" style="margin-top:8px">
            <div>
              <label class="check"><input id="encrypt" type="checkbox"> <span>Encrypt secret (AES-GCM)</span></label>
            </div>
            <div>
              <label class="label" for="passphrase">Passphrase (if encrypting)</label>
              <input id="passphrase" class="input" type="password" placeholder="Enter passphrase">
            </div>
          </div>

          <div class="chips" style="margin-top:10px">
            <button id="embedBtn" class="btn sm" type="button">Embed & Download Stego PNG</button>
            <button id="extractBtn" class="btn sm secondary" type="button">Extract Secret</button>
            <button id="copySecret" class="btn sm ghost" type="button">Copy Extracted</button>
          </div>

          <p class="hint">JPEG recompression destroys LSB. PNG tEXt/trailer may be removed by some apps. Keep originals if secrecy matters.</p>
          <pre id="stegoOut" class="mono scroll" style="margin-top:8px" aria-label="Stego output">Ready.</pre>
        </div>
      </article>
    </section>

    <!-- Video -->
    <section class="card" id="video" style="margin-top:16px">
      <h2 style="margin-top:0">Why EXIF/Metadata Matters (Privacy)</h2>
      <p class="note">Short explainer: what cameras store, and how to remove it safely.</p>
      <div class="center" style="padding:6px">
        <iframe width="560" height="315" loading="lazy"
          src="https://www.youtube.com/embed/6w8GQv8tB7Y"
          title="EXIF Metadata & Privacy - How to remove hidden data from photos"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          referrerpolicy="strict-origin-when-cross-origin"></iframe>
      </div>
    </section>

    <!-- Related internal links -->
    <section class="card" style="margin-top:16px">
      <h2 style="margin-top:0">Related Tools</h2>
      <ul>
        <li><a href="/file-hash/"><span class="ico" aria-hidden="true">FH</span> File Hash (MD5/SHA-256) Verifier</a></li>
        <li><a href="/qr-scanner/"><span class="ico" aria-hidden="true">QR</span> QR Scanner (camera) with risk badges</a></li>
        <li><a href="/browser-fingerprint/"><span class="ico" aria-hidden="true">BF</span> Browser Fingerprint & Tracker Test</a></li>
        <li><a href="/wifi-router/"><span class="ico" aria-hidden="true">WR</span> WiFi Router Tools (Default passwords catalog)</a></li>
        <li><a href="/about/"><span class="ico" aria-hidden="true">ABT</span> About UpTools</a></li>
        <li><a href="/contact/"><span class="ico" aria-hidden="true">CT</span> Contact</a></li>
      </ul>
    </section>

    <section class="card" id="faq" style="margin-top:16px">
      <h2 style="margin-top:0">FAQ</h2>
      <details>
        <summary><strong>Does this upload my images?</strong></summary>
        <p class="note">No. Everything runs locally in your browser.</p>
      </details>
      <details>
        <summary><strong>Will cleaning remove all metadata?</strong></summary>
        <p class="note">Yes, via re-encode (Canvas). PNG keeps pixels; JPEG/WebP re-compress.</p>
      </details>
      <details>
        <summary><strong>Is embedding secrets legal?</strong></summary>
        <p class="note">Use on your own images and only for lawful purposes.</p>
      </details>
    </section>

    <footer class="note small site-footer" role="contentinfo">
      © <span id="y"></span> UpTools · <a href="/sitemap.xml">Sitemap</a> · <a href="/privacy/">Privacy</a>
      <noscript><div class="note danger" style="margin-top:6px">JavaScript is required for local processing. Enable JS to use EXIF Tool.</div></noscript>
    </footer>
  </main>

  <!-- Common utils + Page logic -->
  <script type="module">
    import * as Utils from '/scripts/utils.js';
    const { $, $$, debounce } = Utils;

    // Elements
    const live = $('#live');
    const dropzone = $('#dropzone');
    const pv = $('#preview');
    const fmt = $('#fmt'), dim = $('#dim'), sizeEl = $('#size');
    const exifOut = $('#exifOut'), chunksOut = $('#chunksOut'), flags = $('#flags');
    const exportReportBtn = $('#exportReport'), copyReportBtn = $('#copyReport'), clearAllBtn = $('#clearAll');

    // Improved uploader bits
    const fileInput = $('#file');
    const fileMeta = $('#fileMeta');
    const changeFileBtn = $('#changeFile');
    const removeFileBtn = $('#removeFile');

    const formatOut = $('#formatOut'), jpegQ = $('#jpegQ'), jpegQWrap = $('#jpegQWrap');
    const cleanBtn = $('#cleanBtn'), copyCanvasBtn = $('#copyCanvas'), previewCleanBtn = $('#previewClean'), cleanSize = $('#cleanSize');

    const stegoMode = $('#stegoMode'), secretEl = $('#secret'), fileWrap = $('#fileWrap'), secretFile = $('#secretFile');
    const encryptEl = $('#encrypt'), passphraseEl = $('#passphrase');
    const embedBtn = $('#embedBtn'), extractBtn = $('#extractBtn'), copySecretBtn = $('#copySecret'), stegoOut = $('#stegoOut');

    const yearEl = $('#y'); yearEl.textContent = new Date().getFullYear();

    // State
    let currentFile = null;
    let currentAB = null;
    let currentImg = new Image();
    let metaReport = { exif:{}, chunks:[], trailing:false, format:null, width:null, height:null, fileSize:0, pngTexts:[] };

    // Helpers
    const toKB = (n) => n ? (n<1024? `${n} B` : `${(n/1024).toFixed(1)} KB`) : '—';
    const isPNG = (u8) => u8[0]===0x89 && u8[1]===0x50 && u8[2]===0x4E && u8[3]===0x47;
    const isJPG = (u8) => u8[0]===0xFF && u8[1]===0xD8;
    const isWebP = (u8) => u8[0]===0x52 && u8[1]===0x49 && u8[2]===0x46 && u8[3]===0x46 && u8[8]===0x57 && u8[9]===0x45 && u8[10]===0x42 && u8[11]===0x50;
    const b2str = (b) => new TextDecoder().decode(b);
    const str2bytes = (s) => new TextEncoder().encode(s);
    const setLive = (t)=>{ live.textContent = t || ''; };

    // PNG CRC32 helpers
    const CRC_TABLE = new Uint32Array(256).map((_,n)=>{let c=n;for(let k=0;k<8;k++)c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1));return c>>>0;});
    function crc32(bytes){ let c = 0xFFFFFFFF; for (let i=0;i<bytes.length;i++) c = CRC_TABLE[(c ^ bytes[i]) & 0xFF] ^ (c >>> 8); return (c ^ 0xFFFFFFFF) >>> 0; }
    const u32 = (v)=> new DataView(new Uint8Array([ (v>>>24)&255, (v>>>16)&255, (v>>>8)&255, v&255 ]).buffer);

    // Drag & drop UX
    ['dragover','dragenter'].forEach(ev => dropzone.addEventListener(ev, e=>{ e.preventDefault(); dropzone.classList.add('drag','neon'); }));
    ['dragleave','drop'].forEach(ev => dropzone.addEventListener(ev, e=>{ e.preventDefault(); dropzone.classList.remove('drag','neon'); }));
    dropzone.addEventListener('drop', e => { const f=e.dataTransfer.files?.[0]; if(f) handleFile(f); });
    document.addEventListener('paste', e => { const f=[...e.clipboardData.files][0]; if(f) handleFile(f); });

    // Improved uploader events
    fileInput.addEventListener('change', e => { const f=e.target.files?.[0]; if(f) handleFile(f); });
    changeFileBtn.addEventListener('click', ()=> fileInput.click());
    removeFileBtn.addEventListener('click', ()=> resetUI());

    function resetUI(){
      currentFile=null; currentAB=null; currentImg.src=''; pv.removeAttribute('src'); pv.alt='';
      fileInput.value=''; fileMeta.textContent='No file selected';
      fmt.textContent='—'; dim.textContent='—'; sizeEl.textContent='—'; cleanSize.textContent='—';
      exifOut.textContent='{}'; chunksOut.textContent='[]'; flags.innerHTML='';
      stegoOut.textContent='Ready.'; setLive('');
      secretEl.value=''; secretFile.value='';
    }

    async function handleFile(file){
      resetUI();
      setLive('Loading image…');
      currentFile = file;
      fileMeta.textContent = `${file.name} • ${toKB(file.size)}`;

      currentAB = await file.arrayBuffer();
      const u8 = new Uint8Array(currentAB);
      metaReport.fileSize = file.size;
      metaReport.format = isPNG(u8) ? 'PNG' : isJPG(u8) ? 'JPEG' : isWebP(u8) ? 'WEBP' : (file.type||'Unknown');

      // Preview
      const blobUrl = URL.createObjectURL(file);
      currentImg.onload = () => {
        dim.textContent = `${currentImg.naturalWidth} × ${currentImg.naturalHeight}`;
        metaReport.width=currentImg.naturalWidth; metaReport.height=currentImg.naturalHeight;
        URL.revokeObjectURL(blobUrl);
      };
      pv.src = blobUrl; pv.alt = file.name;

      fmt.textContent = metaReport.format;
      sizeEl.textContent = toKB(file.size);

      await parseMetadata(u8);
      exifOut.textContent = JSON.stringify(metaReport.exif, null, 2).slice(0, 50000) || '{}';
      chunksOut.textContent = JSON.stringify(metaReport.chunks, null, 2).slice(0, 50000) || '[]';
      renderFlags();
      setLive('Image ready.');
    }

    function renderFlags(){
      const e = metaReport.exif||{};
      const arr = [];
      if ('GPSLatitude' in e || 'GPSLongitude' in e) arr.push('<span class="chip-badge danger">GPS</span>');
      if (e.Model) arr.push('<span class="chip-badge">Camera: '+String(e.Model).slice(0,28)+'</span>');
      if (e.Software) arr.push('<span class="chip-badge">Software</span>');
      if (e.DateTimeOriginal||e.CreateDate) arr.push('<span class="chip-badge">Timestamp</span>');
      if (e.ICCProfileName) arr.push('<span class="chip-badge">ICC</span>');
      if (metaReport.pngTexts?.length) arr.push('<span class="chip-badge">PNG text x'+metaReport.pngTexts.length+'</span>');
      if (metaReport.trailing) arr.push('<span class="chip-badge danger">Trailing bytes</span>');
      flags.innerHTML = arr.join(' ') || '<span class="hint">No obvious sensitive tags detected.</span>';
    }

    async function parseMetadata(u8){
      metaReport.exif = {};
      metaReport.chunks = [];
      metaReport.trailing = false;
      metaReport.pngTexts = [];

      try{
        const tags = await exifr.parse(u8.buffer, { xmp:true, tiff:true, icc:true, iptc:true, gps:true, jfif:true, ihdr:true });
        if (tags) {
          const kept = {};
          const keepKeys = ['Make','Model','LensModel','Software','DateTimeOriginal','CreateDate','ModifyDate','Orientation','GPSLatitude','GPSLongitude','GPSAltitude','FNumber','ExposureTime','ISO','FocalLength','ICCProfileName','JFIFVersion','XMP','IPTC','Artist','Copyright'];
          for (const k of keepKeys) if (k in tags) kept[k] = tags[k];
          metaReport.exif = kept;
        }
      }catch(e){}

      if (isJPG(u8)){
        let i=2;
        while (i+4 <= u8.length){
          if (u8[i] !== 0xFF) break;
          const marker = u8[i+1]; i+=2;
          if (marker === 0xD9){
            metaReport.trailing = (i < u8.length);
            if (metaReport.trailing) metaReport.chunks.push({type:'TRAILING', size:u8.length - i});
            break;
          }
          if (marker === 0xDA){
            metaReport.chunks.push({type:'SOS..(scan)..', note:'binary image data'});
            break;
          }
          const len = (u8[i]<<8) | u8[i+1]; i+=2;
          const segType = (marker===0xE1?'APP1': marker===0xED?'APP13': marker===0xFE?'COM': ('FF'+marker.toString(16).toUpperCase()));
          metaReport.chunks.push({type: segType, size: len-2});
          i += len-2;
        }
      } else if (isPNG(u8)){
        let p = 8; let afterIEND = 0;
        while (p+12 <= u8.length){
          const len = (u8[p]<<24)|(u8[p+1]<<16)|(u8[p+2]<<8)|u8[p+3];
          const type = b2str(u8.subarray(p+4, p+8));
          const data = u8.subarray(p+8, p+8+len);
          metaReport.chunks.push({type, size: len});
          if (type==='tEXt'){
            const zero = data.indexOf(0);
            let key='(unknown)', text='';
            if (zero>=0){ key = b2str(data.subarray(0,zero)); text = b2str(data.subarray(zero+1)); }
            metaReport.pngTexts.push({type, key, text});
          }
          if (type==='iTXt'){
            let off=0;
            const readZ = ()=>{ const idx = data.indexOf(0, off); const out = data.subarray(off, idx); off=idx+1; return out; };
            const key = b2str(readZ());
            const compFlag = data[off++]; const compMethod = data[off++];
            const lang = b2str(readZ()); const translated = b2str(readZ());
            const textRaw = data.subarray(off);
            let text = '';
            try{ text = compFlag? new TextDecoder().decode(pako.inflate(textRaw)) : b2str(textRaw); }catch{ text='(decode failed)'; }
            metaReport.pngTexts.push({type, key, compFlag, compMethod, lang, translated, text});
          }
          if (type==='zTXt'){
            const zero = data.indexOf(0);
            const key = b2str(data.subarray(0,zero));
            const method = data[zero+1];
            let text=''; try{ text = new TextDecoder().decode(pako.inflate(data.subarray(zero+2))); }catch{ text='(decode failed)'; }
            metaReport.pngTexts.push({type, key, method, text});
          }
          p += 12 + len;
          if (type==='IEND'){ afterIEND = p; break; }
        }
        if (afterIEND < u8.length){
          metaReport.trailing = true;
          metaReport.chunks.push({type:'TRAILING', size:u8.length - afterIEND});
        }
      } else if (isWebP(u8)){
        let p = 12;
        while (p+8 <= u8.length){
          const type = b2str(u8.subarray(p, p+4));
          const len = u8[p+4] | (u8[p+5]<<8) | (u8[p+6]<<16) | (u8[p+7]<<24);
          metaReport.chunks.push({type, size: len});
          p += 8 + len + (len%2);
        }
        if (p < u8.length){
          metaReport.trailing = true;
          metaReport.chunks.push({type:'TRAILING', size:u8.length - p});
        }
      }
      if (metaReport.pngTexts?.length){
        metaReport.chunks.push({type:'PNG_TEXTS', count: metaReport.pngTexts.length, items: metaReport.pngTexts.slice(0,50)});
      }
    }

    // Export / Copy report
    exportReportBtn.addEventListener('click', ()=>{
      const blob = new Blob([JSON.stringify(metaReport, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `image-report.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    });
    copyReportBtn.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(JSON.stringify(metaReport, null, 2));
        setLive('Report copied.');
      }catch{ alert('Clipboard copy not supported.'); }
    });

    // Cleaner
    formatOut.addEventListener('change', ()=>{
      jpegQWrap.classList.toggle('hidden', formatOut.value!=='image/jpeg');
      cleanSize.textContent = '—';
    });

    async function drawToCanvas(){
      if (!currentFile) return null;
      await new Promise(res=>{
        if (currentImg.complete) return res();
        currentImg.onload = () => res();
      });
      const canvas = document.createElement('canvas');
      canvas.width = currentImg.naturalWidth || currentImg.width;
      canvas.height = currentImg.naturalHeight || currentImg.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(currentImg, 0, 0);
      return canvas;
    }
    async function canvasToBlob(canvas, type, quality){
      return await new Promise(res=> canvas.toBlob(res, type, quality));
    }
    previewCleanBtn.addEventListener('click', async ()=>{
      if (!currentFile) return alert('Load an image first.');
      const canvas = await drawToCanvas();
      const type = formatOut.value;
      const q = (type==='image/jpeg') ? Number(jpegQ.value) : undefined;
      const blob = await canvasToBlob(canvas, type, q);
      cleanSize.textContent = toKB(blob.size);
      setLive('Clean preview size estimated.');
    });
    cleanBtn.addEventListener('click', async ()=>{
      if (!currentFile) return alert('Load an image first.');
      const canvas = await drawToCanvas();
      const type = formatOut.value;
      const q = (type==='image/jpeg') ? Number(jpegQ.value) : undefined;
      const blob = await canvasToBlob(canvas, type, q);
      const a = document.createElement('a');
      const ext = type==='image/png'?'png': type==='image/webp'?'webp':'jpg';
      a.href = URL.createObjectURL(blob);
      a.download = `cleaned.${ext}`;
      a.click();
      URL.revokeObjectURL(a.href);
    });
    copyCanvasBtn.addEventListener('click', async ()=>{
      if (!currentFile) return alert('Load an image first.');
      const canvas = await drawToCanvas();
      const type = formatOut.value;
      const q = (type==='image/jpeg') ? Number(jpegQ.value) : undefined;
      const blob = await canvasToBlob(canvas, type, q);
      try{
        await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
        setLive('Copied clean image to clipboard.');
      }catch{ alert('Clipboard copy not supported in this browser.'); }
    });

    // ---- PNG + Stego utils (unchanged but kept for completeness) ----
    function canvasToPNGBytes(canvas){
      const dataURL = canvas.toDataURL('image/png');
      const b64 = dataURL.split(',')[1];
      const bin = atob(b64);
      const u8 = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
      return u8;
    }
    function bytesToDataURL(u8, mime='image/png'){
      let bin=''; for (let i=0;i<u8.length;i++) bin += String.fromCharCode(u8[i]);
      return `data:${mime};base64,` + btoa(bin);
    }
    function insertPNGTextChunk(pngBytes, key, text){
      let p = 8;
      const len = (pngBytes[p]<<24)|(pngBytes[p+1]<<16)|(pngBytes[p+2]<<8)|pngBytes[p+3];
      const type = b2str(pngBytes.subarray(p+4,p+8));
      if (type!=='IHDR') return pngBytes;
      const afterIHDR = p + 12 + len;
      const keyBytes = str2bytes(key);
      const textBytes = str2bytes(text);
      const data = new Uint8Array(keyBytes.length + 1 + textBytes.length);
      data.set(keyBytes, 0); data[keyBytes.length]=0; data.set(textBytes, keyBytes.length+1);
      const typeBytes = str2bytes('tEXt');
      const crcIn = new Uint8Array(typeBytes.length + data.length);
      crcIn.set(typeBytes, 0); crcIn.set(data, typeBytes.length);
      const out = new Uint8Array(pngBytes.length + 12 + data.length);
      out.set(pngBytes.subarray(0, afterIHDR), 0);
      out.set(u32(data.length), afterIHDR);
      out.set(typeBytes, afterIHDR+4);
      out.set(data, afterIHDR+8);
      out.set(u32(crc32(crcIn)), afterIHDR+8+data.length);
      out.set(pngBytes.subarray(afterIHDR), afterIHDR+12+data.length);
      return out;
    }
    function extractPNGTextChunks(pngBytes){
      const texts = [];
      let p = 8;
      while (p+12 <= pngBytes.length){
        const len = (pngBytes[p]<<24)|(pngBytes[p+1]<<16)|(pngBytes[p+2]<<8)|pngBytes[p+3];
        const type = b2str(pngBytes.subarray(p+4, p+8));
        const data = pngBytes.subarray(p+8, p+8+len);
        if (type==='tEXt'){
          const zero = data.indexOf(0);
          let key='(unknown)', text='';
          if (zero>=0){ key = b2str(data.subarray(0,zero)); text = b2str(data.subarray(zero+1)); }
          texts.push({type, key, text});
        } else if (type==='iTXt'){
          let off=0; const readZ = ()=>{ const idx = data.indexOf(0, off); const out = data.subarray(off, idx); off=idx+1; return out; };
          const key = b2str(readZ()); const compFlag = data[off++]; const compMethod = data[off++];
          const lang = b2str(readZ()); const translated = b2str(readZ());
          const textRaw = data.subarray(off);
          let text = ''; try{ text = compFlag? new TextDecoder().decode(pako.inflate(textRaw)) : b2str(textRaw); }catch{ text='(decode failed)'; }
          texts.push({type, key, compFlag, compMethod, lang, translated, text});
        } else if (type==='zTXt'){
          const zero = data.indexOf(0);
          const key = b2str(data.subarray(0,zero));
          const method = data[zero+1];
          let text=''; try{ text = new TextDecoder().decode(pako.inflate(data.subarray(zero+2))); }catch{ text='(decode failed)'; }
          texts.push({type, key, method, text});
        } else if (type==='IEND'){ break; }
        p += 12 + len;
      }
      return texts;
    }

    // AES-GCM (optional)
    async function deriveKey(passphrase, salt){
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']);
      return crypto.subtle.deriveKey(
        {name:'PBKDF2', salt, iterations: 100000, hash:'SHA-256'},
        baseKey,
        {name:'AES-GCM', length:256},
        false,
        ['encrypt','decrypt']
      );
    }
    async function encryptIfNeeded(bytes){
      if (!$('#encrypt').checked) return { mode:'plain', data: bytes };
      const pass = $('#passphrase').value || '';
      if (!pass) throw new Error('Passphrase required for encryption.');
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(pass, salt);
      const ct = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, bytes));
      return { mode:'aes-gcm', salt: Array.from(salt), iv: Array.from(iv), data: ct };
    }
    async function decryptIfNeeded(wrapper){
      if (!wrapper || !wrapper.mode || wrapper.mode==='plain') return new Uint8Array(wrapper.data||[]);
      if (wrapper.mode!=='aes-gcm') throw new Error('Unknown encryption mode.');
      const salt = new Uint8Array(wrapper.salt);
      const iv = new Uint8Array(wrapper.iv);
      const key = await deriveKey($('#passphrase').value||'', salt);
      const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, new Uint8Array(wrapper.data).buffer);
      return new Uint8Array(pt);
    }

    // LSB
    function lsbCapacityPX(w,h){ return w*h*3; }
    function lsbEncode(canvas, payloadBytes){
      const w=canvas.width, h=canvas.height;
      const ctx = canvas.getContext('2d');
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      const header = str2bytes('UPLS');
      const lenBytes = new Uint8Array(4); new DataView(lenBytes.buffer).setUint32(0, payloadBytes.length, false);
      const payload = new Uint8Array(header.length + 4 + payloadBytes.length);
      payload.set(header,0); payload.set(lenBytes,4); payload.set(payloadBytes,8);
      const bitsNeeded = payload.length * 8;
      if (bitsNeeded > lsbCapacityPX(w,h)) throw new Error('Message too large for this image.');
      let bi=0;
      for (let i=0;i<d.length && bi<bitsNeeded;i+=4){
        for (let c=0;c<3;c++){
          if (bi>=bitsNeeded) break;
          const byteIndex = bi>>3;
          const bitIndex = 7 - (bi & 7);
          const bit = (payload[byteIndex] >> bitIndex) & 1;
          d[i+c] = (d[i+c] & 0xFE) | bit;
          bi++;
        }
      }
      ctx.putImageData(img,0,0);
      return canvas;
    }
    function lsbDecode(canvas){
      const w=canvas.width, h=canvas.height;
      const ctx = canvas.getContext('2d');
      const d = ctx.getImageData(0,0,w,h).data;
      const totalBits = lsbCapacityPX(w,h);
      if (totalBits < 8*8) return null;
      const first = new Uint8Array(8);
      let bi=0;
      for (let i=0;i<d.length && bi<64;i+=4){
        for (let c=0;c<3;c++){
          if (bi>=64) break;
          first[bi>>3] = (first[bi>>3]<<1) | (d[i+c]&1);
          bi++;
        }
      }
      const magic = b2str(first.subarray(0,4));
      if (magic!=='UPLS') return null;
      const msgLen = new DataView(first.buffer).getUint32(4,false);
      const bitsNeeded = (8+msgLen)*8;
      if (bitsNeeded > totalBits) return null;
      const full = new Uint8Array(8 + msgLen);
      let b=0;
      for (let i=0;i<d.length && b<bitsNeeded;i+=4){
        for (let c=0;c<3;c++){
          if (b>=bitsNeeded) break;
          const byteIndex = b>>3;
          full[byteIndex] = (full[byteIndex]<<1) | (d[i+c]&1);
          b++;
        }
      }
      return full.subarray(8);
    }

    // PNG Trailer embed/extract
    function pngAppendTrailer(pngU8, trailerU8){
      const sig = str2bytes('UPTB');
      const len = new Uint8Array(4); new DataView(len.buffer).setUint32(0, trailerU8.length, false);
      const out = new Uint8Array(pngU8.length + 4 + 4 + trailerU8.length);
      out.set(pngU8,0); out.set(sig, pngU8.length); out.set(len, pngU8.length+4); out.set(trailerU8, pngU8.length+8);
      return out;
    }
    function pngReadTrailer(pngU8){
      const sig = 'UPTB'.split('').map(ch=>ch.charCodeAt(0));
      for (let i=pngU8.length-8-1; i>=8; i--){
        if (pngU8[i]===sig[0] && pngU8[i+1]===sig[1] && pngU8[i+2]===sig[2] && pngU8[i+3]===sig[3]){
          const len = new DataView(pngU8.buffer, i+4, 4).getUint32(0,false);
          const start = i+8, end = start+len;
          if (end<=pngU8.length) return pngU8.slice(start,end);
        }
      }
      return null;
    }

    // Stego mode toggles
    stegoMode.addEventListener('change', ()=>{
      $('#fileWrap').classList.toggle('hidden', stegoMode.value!=='pngtrail');
      $('#secret').parentElement.classList.toggle('hidden', stegoMode.value==='pngtrail' && $('#secretFile').files?.length>0);
    });
    secretFile.addEventListener('change', ()=>{
      $('#secret').parentElement.classList.toggle('hidden', secretFile.files?.length>0);
    });

    // Embed
    embedBtn.addEventListener('click', async ()=>{
      if (!currentFile) return alert('Load an image first.');
      const canvas = await drawToCanvas();
      let pngBytes = canvasToPNGBytes(canvas);
      try{
        if (stegoMode.value==='lsb'){
          const text = secretEl.value || '';
          if (!text) return alert('Enter some secret text.');
          const payload = await encryptIfNeeded(str2bytes(text));
          const wrapped = str2bytes(JSON.stringify(payload));
          const stegoCanvas = lsbEncode(canvas, wrapped);
          pngBytes = canvasToPNGBytes(stegoCanvas);
        } else if (stegoMode.value==='pngtext'){
          const text = secretEl.value || '';
          if (!text) return alert('Enter some secret text.');
          const payload = await encryptIfNeeded(str2bytes(text));
          pngBytes = insertPNGTextChunk(pngBytes, 'UpToolsSecret', JSON.stringify(payload));
        } else {
          let bytes;
          if (secretFile.files?.length){
            bytes = new Uint8Array(await secretFile.files[0].arrayBuffer());
          } else {
            const text = secretEl.value || '';
            if (!text) return alert('Enter secret text or choose a file.');
            bytes = str2bytes(text);
          }
          const payload = await encryptIfNeeded(bytes);
          const wrapped = str2bytes(JSON.stringify({ mode: payload.mode, salt: payload.salt, iv: payload.iv, data: Array.from(payload.data) }));
          pngBytes = pngAppendTrailer(pngBytes, wrapped);
        }
      }catch(err){
        console.error(err);
        return alert('Failed to embed: ' + err.message);
      }
      const a = document.createElement('a');
      a.href = bytesToDataURL(pngBytes, 'image/png');
      a.download = 'stego.png';
      a.click();
    });

    // Extract
    extractBtn.addEventListener('click', async ()=>{
      if (!currentFile) return alert('Load an image first.');
      const canvas = await drawToCanvas();
      let results = { lsb:null, pngText:[], trailer:null };
      try{
        const raw = lsbDecode(canvas);
        if (raw){
          try{
            const wrapper = JSON.parse(b2str(raw));
            const plain = await decryptIfNeeded(wrapper);
            results.lsb = new TextDecoder().decode(plain);
          }catch{ results.lsb = '(could not decode)'; }
        }
      }catch{}
      try{
        const bytes = canvasToPNGBytes(canvas);
        const texts = extractPNGTextChunks(bytes);
        for (const t of texts){
          if ((t.key||'')==='UpToolsSecret' && t.text){
            try{
              const wrapper = JSON.parse(t.text);
              const plain = await decryptIfNeeded(wrapper);
              results.pngText.push(new TextDecoder().decode(plain));
            }catch{
              results.pngText.push('(could not decode)');
            }
          } else {
            results.pngText.push(`[${t.type}] ${t.key||''}: ${t.text?.slice(0,400)}`);
          }
        }
      }catch{}
      try{
        const base = canvasToPNGBytes(canvas);
        const trailer = pngReadTrailer(base);
        if (trailer){
          try{
            const wrapper = JSON.parse(b2str(trailer));
            const arr = new Uint8Array((wrapper.data||[]));
            const plain = await decryptIfNeeded({mode:wrapper.mode, salt:wrapper.salt, iv:wrapper.iv, data:arr});
            let asText = null; try{ asText = new TextDecoder().decode(plain); }catch{}
            results.trailer = { bytes: plain.length, preview: asText && /^[\x09\x0A\x0D\x20-\x7E\u00A0-\uFFFF]+$/.test(asText.slice(0,200)) ? asText.slice(0,4000) : '(binary)' };
          }catch{ results.trailer = '(could not decode)'; }
        }
      }catch{}
      stegoOut.textContent = JSON.stringify(results, null, 2);
      if (!results.lsb && (!results.pngText || results.pngText.length===0) && !results.trailer) stegoOut.textContent = 'No embedded secret found (LSB / PNG text / PNG trailer).';
    });
    copySecretBtn.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(stegoOut.textContent||'');
        setLive('Extracted output copied.');
      }catch{ alert('Clipboard copy not supported.'); }
    });

  </script>
</body>
</html>
