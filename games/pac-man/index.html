<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man - Free Online Game | UpTools</title>
  <meta name="description" content="Play Pac-Man online! Eat dots and avoid ghosts in this classic arcade game. Free browser game, no downloads required." />
  <link rel="stylesheet" href="/style.css" />
  <style>
    body { 
      background: #000; 
      color: #ffff00; 
      font-family: Arial, sans-serif; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      margin: 0; 
      touch-action: manipulation;
    }
    .game-container { 
      text-align: center; 
      max-width: 600px; 
      padding: 20px; 
    }
    .game-board { 
      display: grid; 
      grid-template-columns: repeat(19, 20px); 
      gap: 1px; 
      background: #0000ff; 
      padding: 10px; 
      border: 3px solid #0000ff; 
      margin: 20px auto; 
      max-width: fit-content; 
      touch-action: none;
    }
    .cell { 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 12px; 
    }
    .wall { background: #0000ff; }
    .dot { background: #000; }
    .dot::after { content: '¬∑'; color: #ffff00; font-size: 16px; }
    .pacman { background: #000; }
    .pacman::after { content: '‚óè'; color: #ffff00; font-size: 16px; }
    .ghost { background: #000; color: #ff0000; font-size: 14px; }
    .empty { background: #000; }
    .score { 
      font-size: 24px; 
      margin: 10px 0; 
      color: #ffff00; 
    }
    .controls { 
      margin: 20px 0; 
    }
    .mobile-controls {
      display: none;
      grid-template-columns: repeat(3, 48px);
      grid-template-rows: repeat(3, 48px);
      gap: 8px;
      justify-content: center;
      margin: 16px 0;
    }
    .mobile-controls .btn {
      padding: 0;
      width: 48px;
      height: 48px;
      font-size: 18px;
      line-height: 1;
    }
    .mobile-controls .spacer {
      visibility: hidden;
    }
    .btn { 
      background: #ffff00; 
      color: #000; 
      border: none; 
      padding: 10px 20px; 
      border-radius: 5px; 
      cursor: pointer; 
      margin: 5px; 
      font-weight: bold; 
    }
    .btn:hover { 
      background: #ffff99; 
    }
    .instructions { 
      margin: 20px 0; 
      font-size: 14px; 
      color: #ffff00; 
    }

    /* Fullscreen Styles */
    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #ffff00;
      color: #000;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      z-index: 100;
      transition: all 0.2s ease;
    }
    .fullscreen-btn:hover {
      background: #ffff99;
      transform: scale(1.1);
    }

    /* Fullscreen mode styles */
    .fullscreen-mode {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      background: #000 !important;
      z-index: 9999 !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      justify-content: center !important;
      align-items: center !important;
    }

    .fullscreen-mode .game-container {
      max-width: none !important;
      width: 100% !important;
      height: 100% !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
      align-items: center !important;
      padding: 20px !important;
    }

    .fullscreen-mode .game-board {
      grid-template-columns: repeat(19, min(3vmin, 30px)) !important;
      gap: 1px !important;
      padding: 20px !important;
      margin: 20px auto !important;
    }

    .fullscreen-mode .cell {
      width: min(3vmin, 30px) !important;
      height: min(3vmin, 30px) !important;
      font-size: min(2vmin, 16px) !important;
    }

    /* Exit fullscreen button */
    .exit-fullscreen-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ff0000;
      color: white;
      border: none;
      padding: 12px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      z-index: 10000;
      transition: all 0.2s ease;
    }
    .exit-fullscreen-btn:hover {
      background: #ff3333;
      transform: scale(1.05);
    }

    @media (max-width: 768px) {
      .mobile-controls { display: grid; }
      .fullscreen-mode .game-board {
        grid-template-columns: repeat(19, min(4vmin, 25px)) !important;
        padding: 10px !important;
      }
      
      .fullscreen-mode .cell {
        width: min(4vmin, 25px) !important;
        height: min(4vmin, 25px) !important;
        font-size: min(3vmin, 14px) !important;
      }
      
      .fullscreen-mode .score {
        font-size: 20px !important;
      }
      
      .fullscreen-mode .controls {
        margin: 15px 0 !important;
      }
      
      .fullscreen-mode .btn {
        padding: 12px 16px !important;
        margin: 3px !important;
      }
    }
  </style>
</head>
<body>
  <div class="game-container" style="position: relative">
    <button class="fullscreen-btn" id="fullscreenBtn" title="Enter Fullscreen">‚õ∂</button>
    <h1>üëª Pac-Man</h1>
    <div class="score">Score: <span id="score">0</span></div>
    
    <div id="gameBoard" class="game-board"></div>
    
    <div class="controls">
      <button class="btn" id="startBtn">Start Game</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>

    <div class="mobile-controls" aria-label="Mobile controls">
      <button class="btn spacer" aria-hidden="true"> </button>
      <button class="btn" data-move="up">‚Üë</button>
      <button class="btn spacer" aria-hidden="true"> </button>
      <button class="btn" data-move="left">‚Üê</button>
      <button class="btn spacer" aria-hidden="true"> </button>
      <button class="btn" data-move="right">‚Üí</button>
      <button class="btn spacer" aria-hidden="true"> </button>
      <button class="btn" data-move="down">‚Üì</button>
      <button class="btn spacer" aria-hidden="true"> </button>
    </div>
    
    <div class="instructions">
      Use WASD or Arrow Keys to move Pac-Man<br>
      Eat all dots while avoiding ghosts!
    </div>
    
    <div style="margin-top: 20px;">
      <a href="/games/" class="btn">‚Üê Back to Games</a>
    </div>
  </div>

  <script>
    class PacManGame {
      constructor() {
        this.board = [
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
          [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
          [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
          [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
          [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
          [1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1],
          [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
          [1,1,1,1,2,1,0,1,1,0,1,1,0,1,2,1,1,1,1],
          [0,0,0,0,2,0,0,1,0,0,0,1,0,0,2,0,0,0,0],
          [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
          [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
          [1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1],
          [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
          [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
          [1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1],
          [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
          [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
          [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
          [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        this.pacman = { x: 9, y: 15 };
        this.ghosts = [
          { x: 9, y: 9, symbol: 'G' }
        ];
        this.score = 0;
        this.gameRunning = false;
        this.ghostInterval = null;
        
        this.gameBoard = document.getElementById('gameBoard');
        this.scoreElement = document.getElementById('score');
        this.startBtn = document.getElementById('startBtn');
        this.resetBtn = document.getElementById('resetBtn');
        
        this.bindEvents();
        this.renderBoard();
      }
      
      bindEvents() {
        this.startBtn.addEventListener('click', () => this.startGame());
        this.resetBtn.addEventListener('click', () => this.resetGame());
        
        document.addEventListener('keydown', (e) => {
          if (!this.gameRunning) return;
          
          switch(e.key.toLowerCase()) {
            case 'w':
            case 'arrowup':
              this.movePacman(0, -1);
              break;
            case 's':
            case 'arrowdown':
              this.movePacman(0, 1);
              break;
            case 'a':
            case 'arrowleft':
              this.movePacman(-1, 0);
              break;
            case 'd':
            case 'arrowright':
              this.movePacman(1, 0);
              break;
          }
        });

        document.querySelectorAll('.mobile-controls [data-move]').forEach(btn => {
          const move = btn.dataset.move;
          const handler = (e) => {
            e.preventDefault();
            if (!this.gameRunning) return;
            switch (move) {
              case 'up':
                this.movePacman(0, -1);
                break;
              case 'down':
                this.movePacman(0, 1);
                break;
              case 'left':
                this.movePacman(-1, 0);
                break;
              case 'right':
                this.movePacman(1, 0);
                break;
            }
          };
          btn.addEventListener('click', handler);
          btn.addEventListener('touchstart', handler, { passive: false });
        });

        let touchStart = null;
        this.gameBoard.addEventListener('touchstart', (e) => {
          if (!this.gameRunning) return;
          const touch = e.changedTouches[0];
          touchStart = { x: touch.clientX, y: touch.clientY };
        }, { passive: true });
        this.gameBoard.addEventListener('touchend', (e) => {
          if (!this.gameRunning || !touchStart) return;
          const touch = e.changedTouches[0];
          const dx = touch.clientX - touchStart.x;
          const dy = touch.clientY - touchStart.y;
          const absX = Math.abs(dx);
          const absY = Math.abs(dy);
          const threshold = 20;
          if (absX < threshold && absY < threshold) return;
          if (absX > absY) {
            this.movePacman(dx > 0 ? 1 : -1, 0);
          } else {
            this.movePacman(0, dy > 0 ? 1 : -1);
          }
          touchStart = null;
        }, { passive: true });
      }
      
      startGame() {
        this.gameRunning = true;
        this.startBtn.textContent = 'Game Running...';
        this.startBtn.disabled = true;
        if (this.ghostInterval) {
          clearInterval(this.ghostInterval);
        }
        this.ghostInterval = setInterval(() => {
          this.moveGhosts();
        }, 220);
      }
      
      resetGame() {
        this.gameRunning = false;
        this.score = 0;
        this.pacman = { x: 9, y: 15 };
        this.ghosts = [
          { x: 9, y: 9, symbol: 'G' }
        ];
        if (this.ghostInterval) {
          clearInterval(this.ghostInterval);
          this.ghostInterval = null;
        }
        this.updateScore();
        this.renderBoard();
        this.startBtn.textContent = 'Start Game';
        this.startBtn.disabled = false;
      }
      
      movePacman(dx, dy) {
        const newX = this.pacman.x + dx;
        const newY = this.pacman.y + dy;
        
        if (this.isValidMove(newX, newY)) {
          this.pacman.x = newX;
          this.pacman.y = newY;
          
          if (this.board[newY][newX] === 2) {
            this.board[newY][newX] = 0;
            this.score += 10;
            this.updateScore();
          }
          
          this.renderBoard();
          this.checkWin();
          this.checkLoss();
        }
      }
      
      isValidMove(x, y) {
        return y >= 0 && y < this.board.length && 
               x >= 0 && x < this.board[0].length && 
               this.board[y][x] !== 1;
      }
      
      moveGhosts() {
        this.ghosts = this.ghosts.map((ghost) => {
          const moves = [
            { dx: 0, dy: -1 },
            { dx: 0, dy: 1 },
            { dx: -1, dy: 0 },
            { dx: 1, dy: 0 }
          ].filter(move => this.isValidMove(ghost.x + move.dx, ghost.y + move.dy));

          if (!moves.length) return ghost;
          const chase = Math.random() < 0.7;
          let move = moves[Math.floor(Math.random() * moves.length)];
          if (chase) {
            move = moves.reduce((best, current) => {
              const bestDist = Math.abs((ghost.x + best.dx) - this.pacman.x) +
                Math.abs((ghost.y + best.dy) - this.pacman.y);
              const currentDist = Math.abs((ghost.x + current.dx) - this.pacman.x) +
                Math.abs((ghost.y + current.dy) - this.pacman.y);
              return currentDist < bestDist ? current : best;
            }, move);
          }
          return { ...ghost, x: ghost.x + move.dx, y: ghost.y + move.dy };
        });

        this.renderBoard();
        this.checkLoss();
      }

      renderBoard() {
        this.gameBoard.innerHTML = '';
        
        for (let y = 0; y < this.board.length; y++) {
          for (let x = 0; x < this.board[y].length; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            
            if (x === this.pacman.x && y === this.pacman.y) {
              cell.className += ' pacman';
            } else if (this.ghosts.some(ghost => ghost.x === x && ghost.y === y)) {
              cell.className += ' ghost';
              const ghost = this.ghosts.find(g => g.x === x && g.y === y);
              cell.innerHTML = ghost.symbol;
            } else {
              switch(this.board[y][x]) {
                case 1:
                  cell.className += ' wall';
                  break;
                case 2:
                  cell.className += ' dot';
                  break;
                default:
                  cell.className += ' empty';
              }
            }
            
            this.gameBoard.appendChild(cell);
          }
        }
      }
      
      checkWin() {
        const dotsRemaining = this.board.flat().filter(cell => cell === 2).length;
        if (dotsRemaining === 0) {
          alert('You Win! All dots collected!');
          this.resetGame();
        }
      }

      checkLoss() {
        const hitGhost = this.ghosts.some(ghost => ghost.x === this.pacman.x && ghost.y === this.pacman.y);
        if (hitGhost) {
          alert('Game Over! A ghost caught you!');
          this.resetGame();
        }
      }
      
      updateScore() {
        this.scoreElement.textContent = this.score;
      }
    }
    
    // Initialize game when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new PacManGame();
      
      // Fullscreen functionality
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      let isFullscreen = false;
      let exitFullscreenBtn = null;

      function enterFullscreen() {
        isFullscreen = true;
        document.body.classList.add('fullscreen-mode');
        
        // Create exit button
        exitFullscreenBtn = document.createElement('button');
        exitFullscreenBtn.className = 'exit-fullscreen-btn';
        exitFullscreenBtn.innerHTML = '‚úï Exit Fullscreen';
        exitFullscreenBtn.onclick = exitFullscreen;
        document.body.appendChild(exitFullscreenBtn);
        
        fullscreenBtn.style.display = 'none';
      }

      function exitFullscreen() {
        isFullscreen = false;
        document.body.classList.remove('fullscreen-mode');
        
        // Remove exit button
        if (exitFullscreenBtn) {
          exitFullscreenBtn.remove();
          exitFullscreenBtn = null;
        }
        
        fullscreenBtn.style.display = 'block';
      }

      fullscreenBtn.addEventListener('click', enterFullscreen);

      // Exit fullscreen on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isFullscreen) {
          exitFullscreen();
        }
      });
    });
  </script>
</body>
</html>
