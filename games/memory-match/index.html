<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Single async ad (kept minimal for performance) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6216304334889617" crossorigin="anonymous"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Memory Match - Free Online Game (Easy/Medium/Hard, Peek, Best Time) | UpTools</title>
  <meta name="description" content="Play Memory Match online for free on any device. Flip cards and match pairs with Easy, Medium, and Hard modes. Features: smart peek start, keyboard support, sound & haptics toggles, per-level best time tracking, and a responsive play area that fills the screen and never overflows. How to play: choose a difficulty, memorize the board during the short peek, then flip two cards at a time to find all pairs in the fewest moves and fastest time." />
  <meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:large" />
  <meta name="theme-color" content="#0f1419" />

  <!-- Canonical / OG -->
  <link rel="canonical" href="https://www.uptools.in/games/memory-match" />
  <meta property="og:title" content="Memory Match - Free Online Game | UpTools" />
  <meta property="og:description" content="Test your memory with a fast, polished Memory Match. Peek start, sounds, haptics & best-time tracking. Always fits your screen." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.uptools.in/games/memory-match" />
  <meta property="og:site_name" content="UpTools" />
  <meta property="og:image" content="/assets/og/memory-match.png" />
  <meta name="twitter:card" content="summary_large_image" />

  <!-- Favicon -->
  <link rel="icon" sizes="50x50" type="image/svg+xml" href="/assets/logo/uptools-logo.svg">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/logo/uptools-logo.svg">

  <!-- Performance hints -->
  <link rel="preconnect" href="https://pagead2.googlesyndication.com" crossorigin>
  <link rel="dns-prefetch" href="//pagead2.googlesyndication.com">

  <!-- Common CSS (shared across site) -->
  <link rel="preload" href="/style.css?v=1.2.3" as="style">
  <link rel="stylesheet" href="/style.css?v=1.2.3" media="print" onload="this.media='all'">
  <noscript><link rel="stylesheet" href="/style.css?v=1.2.3"></noscript>

  <!-- Page micro-styles (tiny + CLS-safe) -->
  <style>
    :root{
      --accent:#4ecdc4; --accent2:#5fe1d8; --danger:#ff6b6b; --bg:#0f1419;
      --bg1:#0f1419; --bg2:#121a26; --card:#1e2634; --cardBorder:#2a3b55; --muted:#9aa4b2;
    }
    body{
      background: radial-gradient(1200px 600px at 10% -10%, #162130 0%, var(--bg) 45%) fixed;
      min-height: 100svh;
    }

    .tool-header{ text-align:center; margin:1rem 0 .25rem }
    .tool-header h1{ display:flex; align-items:center; justify-content:center; gap:.5rem }
    .tool-header p{ margin:.25rem 0 0 }

    .back-btn{
      appearance:none; background:transparent; color:var(--text,#e6edf3);
      border:1px solid var(--cardBorder); border-radius:.6rem;
      padding:.4rem .7rem; font-weight:700; cursor:pointer;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .back-btn:hover{ transform:translateY(-1px); border-color:var(--accent); background:rgba(255,255,255,.03) }

    .game-wrap{ max-width:1100px; margin:0 auto; padding:1rem; }
    .panel{
      background:var(--card); border:1px solid var(--cardBorder);
      border-radius:var(--radius,.75rem); box-shadow:var(--shadow,0 6px 30px rgba(0,0,0,.25));
      padding:1rem; margin:0 auto; overflow:hidden;
    }

    .hud{ display:grid; grid-template-columns:repeat(4,1fr); gap:.75rem; align-items:center; margin-bottom:.75rem; }
    .kpi{ text-align:center; padding:.5rem .75rem; border:1px solid var(--cardBorder); border-radius:.75rem; background:rgba(255,255,255,.02) }
    .kpi .value{ font-size:1.35rem; font-weight:800; color:var(--accent) }
    .kpi .label{ font-size:.8rem; color:var(--muted) }

    .bar{ display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; justify-content:center; margin:.5rem 0 0; }
    .difficulty-btn{
      padding:.5rem .8rem; border-radius:.6rem; border:1px solid var(--cardBorder);
      background:#0f151f; color:var(--text,#e6edf3); font-weight:700; cursor:pointer;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .difficulty-btn:hover{ border-color:var(--accent) }
    .difficulty-btn.active{ background:var(--accent); color:#0b1020; border-color:var(--accent) }

    .controls{ display:flex; flex-wrap:wrap; gap:.5rem; justify-content:center; margin: .75rem 0 0 }
    .btn{ padding:.6rem 1rem; border:none; border-radius:.75rem; font-weight:700; cursor:pointer; transition: transform .12s ease, box-shadow .12s ease; }
    .btn.primary{ background:var(--accent); color:#0b1020 }
    .btn.secondary{ background:transparent; color:var(--text,#e6edf3); border:1px solid var(--cardBorder) }
    .btn:hover{ transform:translateY(-1px); box-shadow:var(--shadow-hover,0 8px 26px rgba(0,0,0,.25)) }

    .status{ text-align:center; margin:.75rem 0 0; color:var(--muted); font-weight:600 }

    /* =========================
       GRID - always fits container
       ========================= */
    .grid{
      --gap: clamp(6px, 2.2vw, 14px);
      display:grid; gap: var(--gap);
      margin:1rem auto; justify-content:center;
      width: 100%; max-width: 100%;
    }
    .grid.easy, .grid.medium, .grid.hard{
      grid-template-columns: repeat(var(--cols,4), var(--tile,72px));
      grid-auto-rows: var(--tile,72px);
    }

    /* Card tiles */
    .card-tile{
      aspect-ratio:1; position:relative; border-radius:12px;
      border:2px solid var(--cardBorder); background:#0f151f;
      display:grid; place-items:center; cursor:pointer; user-select:none;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
      outline: none;
      min-width: 26px; min-height: 26px;
    }
    .card-tile:hover{ transform:translateY(-1px); border-color:var(--accent) }
    .card-tile:focus-visible{ box-shadow:0 0 0 3px color-mix(in hsl, var(--accent) 35%, transparent); border-color:var(--accent) }

    .face{
      font-size: clamp(16px, calc(var(--tile,72px) * .42), 40px);
      transform:scale(.85); opacity:0; transition:opacity .12s ease, transform .12s ease;
    }
    .flipped .face{ opacity:1; transform:scale(1) }
    .flipped{ background:linear-gradient(135deg, #0f151f, #203040); border-color:var(--accent) }

    .matched{ background:var(--accent); border-color:var(--accent); animation: pulse .35s ease-in-out; color:#0b1020; }
    .matched .face{ opacity:1 }
    @keyframes pulse{ 0%,100%{ transform:scale(1)} 50%{ transform:scale(1.05)} }

    .peek .card-tile .face{ opacity:1; transform:scale(1) }
    .peek .card-tile{ border-color:rgba(255,255,255,.15) }

    /* When the play area is locked during a run */
    .board-locked{ will-change: auto; }

    /* Tighten on small phones */
    @media (max-width:520px){
      .hud{ grid-template-columns:repeat(2,1fr); }
      .panel{ padding:.75rem; }
    }

    /* SEO video (fixed size to avoid CLS) */
    .video-wrap{ width:560px; height:315px; max-width:100%; margin:1rem auto 0; border:1px solid var(--cardBorder); border-radius:.6rem; overflow:hidden; }
    .video-wrap iframe{ width:560px; height:315px; border:0; display:block; }
  </style>

  <!-- Structured data for the game -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"Game",
    "name":"Memory Match",
    "url":"https://www.uptools.in/games/memory-match",
    "applicationCategory":"Game",
    "operatingSystem":"Any",
    "publisher":{"@type":"Organization","name":"UpTools"},
    "sameAs":[
      "https://www.uptools.in/games/",
      "https://www.uptools.in/"
    ]
  }
  </script>
</head>
<body>
  <!-- Site header (shared pattern) -->
  <header class="site" role="banner">
    <div class="header-inner">
      <a class="brand" href="/" aria-label="UpTools Home">
        <img src="/assets/logo/uptools-logo.svg" alt="UpTools logo" width="28" height="28" loading="eager">
        <b>UpTools</b>
      </a>
      <nav class="nav-links" aria-label="Primary">
        <a href="/#tools">Tools</a>
        <a href="/games/">Games</a>
        <a href="/about/">About</a>
        <a href="/contact/">Contact</a>
      </nav>
    </div>
  </header>

  <main class="wrap" id="main">
    <div class="tool-header">
      <button id="backSmart" class="back-btn" type="button" aria-label="Back to games">‚Üê Back</button>
      <h1>üß† Memory Match</h1>
      <p>Flip cards and match pairs. How fast can you complete it?</p>
    </div>

    <div class="game-wrap">
      <section class="panel">
        <div class="hud" aria-live="polite">
          <div class="kpi"><div class="value" id="timer">00:00</div><div class="label">Time</div></div>
          <div class="kpi"><div class="value" id="moves">0</div><div class="label">Moves</div></div>
          <div class="kpi"><div class="value" id="pairs">0</div><div class="label">Pairs Found</div></div>
          <div class="kpi"><div class="value" id="best">--:--</div><div class="label">Best</div></div>
        </div>

        <div class="bar" role="toolbar" aria-label="Difficulty">
          <button class="difficulty-btn" data-level="easy">Easy (8 cards)</button>
          <button class="difficulty-btn" data-level="medium">Medium (18 cards)</button>
          <button class="difficulty-btn" data-level="hard">Hard (32 cards)</button>
        </div>

        <div id="status" class="status">Tap any card to start. You'll get a quick peek!</div>

        <!-- PLAY AREA (kept inside a wrapper we can size/lock) -->
        <div id="boardWrap" class="panel" style="padding:.75rem; margin-top:.75rem">
          <div id="grid" class="grid easy" role="grid" aria-label="Memory cards"></div>
        </div>

        <div class="controls">
          <button id="newGame" class="btn primary">New Game</button>
          <button id="resetBest" class="btn secondary">Reset Best Times</button>
          <button id="toggleSound" class="btn secondary" aria-pressed="true">üîä Sound On</button>
          <button id="toggleHaptics" class="btn secondary" aria-pressed="true">üì≥ Haptics On</button>
        </div>

        <!-- Fixed-size YouTube (SEO-supporting, no layout shift) -->
        <details class="panel" style="margin-top:.75rem">
          <summary><b>üé¨ How to play & tips</b></summary>
          <div class="video-wrap">
            <iframe loading="lazy" title="How to play Memory Match (tips)"
              src="https://www.youtube.com/embed/5jK8kGmCazA?rel=0"
              width="560" height="315" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              referrerpolicy="strict-origin-when-cross-origin"></iframe>
          </div>
          <ul class="small" style="margin:.75rem 1rem 0">
            <li>Memorize during the <i>peek</i> phase, then flip two cards per move.</li>
            <li>Use keyboard: <kbd>Enter</kbd>/<kbd>Space</kbd> to flip, <kbd>Esc</kbd> to go back.</li>
            <li>Best times are stored per difficulty on your device.</li>
          </ul>
        </details>
      </section>
    </div>

    <footer class="site-foot small" style="text-align:center; margin:1rem 0 2rem">
      <nav class="nav-links small">
        <a href="/">UpTools</a> ¬∑ <a href="/sitemap.xml">Sitemap</a> ¬∑ <a href="/games/">Games</a> ¬∑ <a href="/about/">ABT</a> ¬∑ <a href="/contact/">CT</a>
      </nav>
      <div class="note">Privacy-first ¬∑ Works offline once loaded</div>
      <nav class="nav-links small" style="margin-top:.25rem">
        Related: <a href="/games/color-rush/">Color Rush</a> ¬∑ <a href="/games/snake/">Snake</a>
      </nav>
    </footer>
  </main>

  <!-- Optional ad slot (ONLY IF you have a valid slot; otherwise keep commented to avoid CLS) -->
  <!--
  <section class="card">
    <ins class="adsbygoogle"
         style="display:block;min-height:120px"
         data-ad-client="ca-pub-6216304334889617"
         data-ad-slot="YOUR_SLOT_ID"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>
  </section>
  -->

  <!-- Common helpers -->
  <script type="module" src="/scripts/utils.js"></script>
  <script>
    (() => {
      // ---------- Utilities
      const $ = (s, el=document) => el.querySelector(s);
      const randInt = (n) => (Math.random() * n) | 0;

      // Prevent arrow keys / Space from scrolling the page (keeps play area steady)
      window.addEventListener("keydown", (e) => {
        const k = e.key;
        if (k === "ArrowUp" || k === "ArrowDown" || k === " ") {
          e.preventDefault();
        }
      }, { passive:false });

      // Smart back
      $("#backSmart").addEventListener("click", () => {
        if (history.length > 1) history.back();
        else window.location.href = "/games/?played=memory-match";
      });

      // Toggles
      let soundOn = JSON.parse(localStorage.getItem("mem-sound") ?? "true");
      let hapticsOn = JSON.parse(localStorage.getItem("mem-haptics") ?? "true");
      const btnSound = $("#toggleSound");
      const btnHaptics = $("#toggleHaptics");
      const setToggle = (btn, on, labelOn, labelOff) => {
        btn.setAttribute("aria-pressed", String(on));
        btn.textContent = on ? labelOn : labelOff;
      };
      setToggle(btnSound, soundOn, "üîä Sound On", "üîá Sound Off");
      setToggle(btnHaptics, hapticsOn, "üì≥ Haptics On", "üì¥ Haptics Off");
      btnSound.addEventListener("click", () => {
        soundOn = !soundOn; localStorage.setItem("mem-sound", JSON.stringify(soundOn));
        setToggle(btnSound, soundOn, "üîä Sound On", "üîá Sound Off");
      });
      btnHaptics.addEventListener("click", () => {
        hapticsOn = !hapticsOn; localStorage.setItem("mem-haptics", JSON.stringify(hapticsOn));
        setToggle(btnHaptics, hapticsOn, "üì≥ Haptics On", "üì¥ Haptics Off");
      });

      // WebAudio bleeps (no files)
      let audioCtx = null;
      const beep = (type="square", freq=440, ms=80, gain=0.025) => {
        if (!soundOn) return;
        try{
          audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); }, ms);
        }catch{}
      };
      const buzz = (ms=15) => { if (hapticsOn && navigator.vibrate) navigator.vibrate(ms); };

      // ---------- Game
      class MemoryMatch {
        constructor(){
          // Emoji pool (>= 32 unique)
          this.pool = [
            "üçé","üçä","üçã","üçâ","üçá","üçì","üçí","üçç","ü•ù","ü•ë","ü•ï","üå∂Ô∏è","üçÑ","ü•®","üç™","üç∞",
            "üê∂","üê±","üê≠","üêπ","üê∞","ü¶ä","üêª","üêº","ü¶Å","üêØ","ü¶Ñ","üê∏","üêµ","üêô","üê†","ü¶ã"
          ];
          this.cfg = {
            easy:   { pairs: 4,  cols: 4,  minTile: 64 }, // 8 cards -> 4x2
            medium: { pairs: 9,  cols: 6,  minTile: 42 }, // 18 cards -> 6x3
            hard:   { pairs: 16, cols: 8,  minTile: 28 }  // 32 cards -> 8x4
          };

          // State
          this.level = localStorage.getItem("mem-level") || "easy";
          this.cards = [];
          this.flipped = [];
          this.pairsFound = 0;
          this.moves = 0;
          this.peeking = false;
          this.locked = false;       // prevents flipping during mismatch
          this.running = false;      // timer running?
          this.seconds = 0;
          this.tid = null;

          // Play area lock (sticks while playing)
          this.sizeLock = null;      // { innerW, innerH }
          this._resizeObs = null;

          // DOM
          this.grid = $("#grid");
          this.boardWrap = $("#boardWrap");
          this.timerEl = $("#timer");
          this.movesEl = $("#moves");
          this.pairsEl = $("#pairs");
          this.bestEl = $("#best");
          this.statusEl = $("#status");

          // Wire UI
          this.bindUI();
          this.setLevel(this.level);
          this.newGame(true); // initial render with peek

          // Responsive sizing hooks (active only when NOT locked)
          const layoutNow = () => this.layout();
          window.addEventListener("resize", layoutNow, { passive: true });
          window.addEventListener("orientationchange", layoutNow);
          this._resizeObs = new ResizeObserver(layoutNow);
          this._resizeObs.observe(this.boardWrap);
          requestAnimationFrame(layoutNow);
        }

        bindUI(){
          // Difficulty
          document.querySelectorAll(".difficulty-btn").forEach(btn=>{
            btn.addEventListener("click", () => this.setLevel(btn.dataset.level, btn));
          });
          // New game & reset best
          $("#newGame").addEventListener("click", () => this.newGame(true));
          $("#resetBest").addEventListener("click", () => this.resetBest());

          // Keyboard: Esc back to /games
          window.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              if (history.length > 1) history.back();
              else window.location.href = "/games/?played=memory-match";
            }
          });
        }

        setLevel(level, btn){
          if (!this.cfg[level]) level = "easy";
          this.level = level;
          localStorage.setItem("mem-level", level);
          // button state
          document.querySelectorAll(".difficulty-btn").forEach(b=>b.classList.remove("active"));
          const activeBtn = btn || document.querySelector(`.difficulty-btn[data-level="${level}"]`);
          if (activeBtn) activeBtn.classList.add("active");
          // grid class
          this.grid.className = "grid " + level;
          this.updateBestDisplay();
          this.layout(); // ensure correct sizing when level changes (honors size lock)
        }

        cardTemplate(id, symbol){
          const el = document.createElement("button");
          el.className = "card-tile";
          el.setAttribute("type","button");
          el.setAttribute("role","gridcell");
          el.setAttribute("aria-label","Hidden card");
          el.dataset.id = id;
          el.dataset.symbol = symbol;
          el.innerHTML = `<span class="face" aria-hidden="true">${symbol}</span>`;
          el.addEventListener("click", () => this.flip(el));
          el.addEventListener("keydown", (e)=> {
            if (e.key === " " || e.key === "Enter") { e.preventDefault(); this.flip(el); }
          });
          return el;
        }

        buildDeck(){
          const { pairs } = this.cfg[this.level];
          const symbols = [...this.pool].slice(0, pairs);
          const deck = [];
          let id = 0;
          for (const s of symbols){
            deck.push({ id:id++, symbol:s, matched:false });
            deck.push({ id:id++, symbol:s, matched:false });
          }
          // shuffle
          for (let i = deck.length - 1; i > 0; i--){
            const j = randInt(i+1);
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }
          return deck;
        }

        mountBoard(deck){
          this.grid.innerHTML = "";
          this.cards = deck.map(card => {
            const el = this.cardTemplate(card.id, card.symbol);
            this.grid.appendChild(el);
            return { ...card, el };
          });
          // focus first tile for keyboard users
          const first = this.grid.querySelector(".card-tile");
          if (first) first.focus({ preventScroll:true });
          // layout after DOM paint
          requestAnimationFrame(() => this.layout());
        }

        newGame(withPeek=false){
          // Unlock play area for a fresh measurement cycle
          this.unlockPlayArea();

          this.stopTimer();
          this.seconds = 0; this.moves = 0; this.pairsFound = 0;
          this.flipped = []; this.locked = false; this.running = false;
          this.updateHUD();

          const deck = this.buildDeck();
          this.mountBoard(deck);

          // peek phase
          if (withPeek){
            this.statusEl.textContent = "Memorize the board‚Ä¶";
            document.body.classList.add("peek");
            this.cards.forEach(c => c.el.classList.add("flipped"));
            setTimeout(() => {
              document.body.classList.remove("peek");
              this.cards.forEach(c => c.el.classList.remove("flipped"));
              this.statusEl.textContent = "Go! Flip two cards to start the timer.";
              this.peeking = false;
              this.layout(); // in case viewport changed during peek
            }, 1500);
            this.peeking = true;
          } else {
            this.statusEl.textContent = "Tap any card to start!";
          }
        }

        start(){
          if (this.running) return;
          // Lock the play area the moment the game actually starts
          this.lockPlayArea();
          this.running = true;
          this.tid = setInterval(()=>{ this.seconds++; this.updateHUD() }, 1000);
        }

        stopTimer(){
          if (this.tid){ clearInterval(this.tid); this.tid = null; }
          this.running = false;
        }

        flip(el){
          if (this.peeking || this.locked) return;
          if (el.classList.contains("matched") || el.classList.contains("flipped")) return;

          if (!this.running) this.start();

          el.classList.add("flipped");
          el.setAttribute("aria-label","Revealed card");
          beep("triangle", 560, 50, .02);

          this.flipped.push(el);
          if (this.flipped.length === 2){
            this.moves++; this.updateHUD();
            this.checkMatch();
          }
        }

        checkMatch(){
          const [a, b] = this.flipped;
          const same = a.dataset.symbol === b.dataset.symbol;
          if (same){
            a.classList.add("matched"); b.classList.add("matched");
            this.pairsFound++;
            this.flipped = [];
            beep("sine", 760, 90, .03); buzz(12);
            this.updateHUD();
            if (this.pairsFound === this.cfg[this.level].pairs){
              this.finish();
            }
          } else {
            this.locked = true;
            beep("sawtooth", 220, 90, .025);
            setTimeout(()=>{
              a.classList.remove("flipped"); b.classList.remove("flipped");
              a.setAttribute("aria-label","Hidden card");
              b.setAttribute("aria-label","Hidden card");
              this.flipped = [];
              this.locked = false;
            }, 650);
          }
        }

        finish(){
          this.stopTimer();
          const t = this.formatTime(this.seconds);
          this.statusEl.innerHTML = `üéâ Completed in <b>${t}</b> with ${this.moves} moves!`;
          const key = `mem-best-${this.level}`;
          const cur = +(localStorage.getItem(key) || 0);
          if (cur === 0 || this.seconds < cur){
            localStorage.setItem(key, String(this.seconds));
          }
          this.updateBestDisplay();
          // Keep size lock until user clicks "New Game" (so the board never jumps)
        }

        resetBest(){
          Object.keys(this.cfg).forEach(l => localStorage.removeItem(`mem-best-${l}`));
          this.updateBestDisplay();
          this.statusEl.textContent = "Best times reset. Good luck!";
        }

        updateBestDisplay(){
          const key = `mem-best-${this.level}`;
          const s = localStorage.getItem(key);
          this.bestEl.textContent = s ? this.formatTime(+s) : "--:--";
        }

        updateHUD(){
          this.timerEl.textContent = this.formatTime(this.seconds);
          this.movesEl.textContent = this.moves;
          this.pairsEl.textContent = this.pairsFound;
        }

        formatTime(sec){
          const m = Math.floor(sec/60), s = sec%60;
          return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
        }

        /* -------------------------------------------
           Play area lock: sticks while playing
           - lockPlayArea(): compute near-full-screen area and freeze it
           - unlockPlayArea(): remove styles (for fresh games)
           ------------------------------------------- */
        lockPlayArea(){
          // Compute available inner width/height BEFORE locking
          const { innerW, innerH } = this._measureAvailableInner();
          // Use ~92% of height to leave breathing room on tiny screens
          const targetH = Math.max(180, Math.floor(innerH * 0.92));
          const targetW = Math.max(200, Math.floor(innerW));

          this.sizeLock = { innerW: targetW, innerH: targetH };

          // Freeze wrapper size (includes padding already on the element)
          const wrap = this.boardWrap;
          const cs = getComputedStyle(wrap);
          const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
          const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

          // Set explicit dimensions so the page does not jump during play
          wrap.style.width = `${wrap.clientWidth}px`;   // keep current width to avoid sudden expansion
          wrap.style.maxWidth = `${wrap.clientWidth}px`;
          wrap.style.height = `${targetH + padY}px`;
          wrap.style.maxHeight = `${targetH + padY}px`;
          wrap.classList.add("board-locked");

          this.layout(); // lay out tiles to the locked box
        }

        unlockPlayArea(){
          const wrap = this.boardWrap;
          wrap.style.width = "";
          wrap.style.maxWidth = "";
          wrap.style.height = "";
          wrap.style.maxHeight = "";
          wrap.classList.remove("board-locked");
          this.sizeLock = null;
        }

        _measureAvailableInner(){
          const wrap = this.boardWrap;
          const rect = wrap.getBoundingClientRect();
          const cs = getComputedStyle(wrap);
          const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
          const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
          const bLeft  = parseFloat(cs.borderLeftWidth)  || 0;
          const bRight = parseFloat(cs.borderRightWidth) || 0;

          // Available width is the wrapper's current content box width
          const innerW = Math.max(160, wrap.clientWidth - padX - bLeft - bRight);

          // Available height is from wrapper top to viewport bottom minus a small margin
          const viewportH = window.innerHeight;
          const marginBottom = 24;
          const innerH = Math.max(180, viewportH - rect.top - marginBottom - padY);

          return { innerW, innerH };
        }

        /* ------------------------------------------------
           Responsive layout calculator - NO OVERFLOW
           Tiles shrink (esp. on Hard) to always fit
           Honors sizeLock if present
           ------------------------------------------------ */
        layout(){
          const cfg = this.cfg[this.level];
          const cols = cfg.cols;
          const rows = Math.ceil((cfg.pairs * 2) / cols);

          // expose to CSS
          this.grid.style.setProperty('--cols', cols);

          // current wrapper metrics
          const wrap = this.boardWrap;
          const wrapCS = getComputedStyle(wrap);
          const padX = parseFloat(wrapCS.paddingLeft) + parseFloat(wrapCS.paddingRight);
          const padY = parseFloat(wrapCS.paddingTop) + parseFloat(wrapCS.paddingBottom);
          const bLeft  = parseFloat(wrapCS.borderLeftWidth)  || 0;
          const bRight = parseFloat(wrapCS.borderRightWidth) || 0;
          const gridCS = getComputedStyle(this.grid);
          const gridGap = parseFloat(gridCS.gap) || 10;

          let availW, availH;

          if (this.sizeLock){
            // Use locked inner size (content area)
            availW = Math.max(160, this.sizeLock.innerW - bLeft - bRight - padX);
            availH = Math.max(180, this.sizeLock.innerH - padY);
          } else {
            // Free mode: measure dynamically to nearly fill screen
            const measured = this._measureAvailableInner();
            availW = measured.innerW;
            availH = measured.innerH;
          }

          // Candidate tile sizes
          const tileW = Math.floor((availW - (cols - 1) * gridGap) / cols);
          const tileH = Math.floor((availH - (rows - 1) * gridGap) / rows);

          // Allow difficulty-based minimums
          const minTile = cfg.minTile; // 64 / 42 / 28
          const tile = Math.max(minTile, Math.min(tileW, tileH));

          // Apply tile size
          this.grid.style.setProperty('--tile', tile + 'px');

          // Compute intended board width, clamp to available width to avoid overflow
          const boardW = cols * tile + (cols - 1) * gridGap;
          const finalW = Math.min(boardW, availW);
          this.grid.style.maxWidth = '100%';
          this.grid.style.width = finalW + 'px';
        }
      }

      // Boot
      new MemoryMatch();
    })();
  </script>
</body>
</html>
