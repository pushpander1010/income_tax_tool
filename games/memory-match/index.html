<!DOCTYPE html>
<html lang="en">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6216304334889617" crossorigin="anonymous"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Memory Match ‚Äì Free Online Game | UpTools</title>
  <meta name="description" content="Play Memory Match online for free. Flip cards, remember positions, and match pairs. Multiple difficulties, peek start, sounds, haptics, and best-time tracking." />
  <meta name="robots" content="index,follow" />
  <meta name="theme-color" content="#0f1419" />
  <meta property="og:title" content="Memory Match ‚Äì Free Online Game | UpTools" />
  <meta property="og:description" content="Test your memory with a fast, polished Memory Match. Peek, sounds, and best-time tracking." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.uptools.in/games/memory-match" />
  <meta property="og:site_name" content="UpTools" />
  <link rel="canonical" href="https://www.uptools.in/games/memory-match" />
  <link rel="stylesheet" href="/style.css?v=1.0.0"/>

  <style>
    body{
      --accent:#4ecdc4;
      --accent2:#5fe1d8;
      --danger:#ff6b6b;
      --bg:#0f1419;
      --card:#1e2634;
      --muted:#9aa4b2;
      background: radial-gradient(1200px 600px at 10% -10%, #162130 0%, var(--bg) 45%) fixed;
    }

    .tool-header{ text-align:center; margin:1rem 0 .25rem }
    .tool-header h1{ display:flex; align-items:center; justify-content:center; gap:.5rem }
    .tool-header p{ margin:.25rem 0 0 }

    /* Smart back button */
    .back-btn{
      appearance:none; background:transparent; color:var(--text);
      border:1px solid var(--cardBorder); border-radius:.6rem;
      padding:.4rem .7rem; font-weight:700; cursor:pointer;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .back-btn:hover{ transform:translateY(-1px); border-color:var(--accent); background:rgba(255,255,255,.03) }

    .game-wrap{ max-width:980px; margin:0 auto; padding:1rem; }
    .panel{
      background:var(--card); border:1px solid var(--cardBorder);
      border-radius:var(--radius); box-shadow:var(--shadow);
      padding:1rem; margin:0 auto;
    }

    .hud{
      display:grid; grid-template-columns:repeat(4,1fr);
      gap:.75rem; align-items:center; margin-bottom:.75rem;
    }
    .kpi{
      text-align:center; padding:.5rem .75rem; border:1px solid var(--cardBorder);
      border-radius:.75rem; background:rgba(255,255,255,.02)
    }
    .kpi .value{ font-size:1.35rem; font-weight:800; color:var(--accent) }
    .kpi .label{ font-size:.8rem; color:var(--muted) }

    .bar{
      display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; justify-content:center; margin:.5rem 0 0;
    }
    .difficulty-btn{
      padding:.5rem .8rem; border-radius:.6rem; border:1px solid var(--cardBorder);
      background:#0f151f; color:var(--text); font-weight:700; cursor:pointer;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .difficulty-btn:hover{ border-color:var(--accent) }
    .difficulty-btn.active{ background:var(--accent); color:#0b1020; border-color:var(--accent) }

    .controls{ display:flex; gap:.5rem; justify-content:center; margin: .75rem 0 0 }
    .btn{
      padding:.6rem 1rem; border:none; border-radius:.75rem; font-weight:700; cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn.primary{ background:var(--accent); color:#0b1020 }
    .btn.secondary{ background:transparent; color:var(--text); border:1px solid var(--cardBorder) }
    .btn:hover{ transform:translateY(-1px); box-shadow:var(--shadow-hover) }

    .status{ text-align:center; margin:.75rem 0 0; color:var(--muted); font-weight:600 }

    /* Grid */
    .grid{
      display:grid; gap:10px; margin:1rem auto; justify-content:center;
    }
    .grid.easy   { grid-template-columns:repeat(4,1fr); max-width: 440px; }
    .grid.medium { grid-template-columns:repeat(6,1fr); max-width: 660px; }
    .grid.hard   { grid-template-columns:repeat(8,1fr); max-width: 880px; }

    /* Card */
    .card-tile{
      aspect-ratio:1; position:relative; border-radius:12px;
      border:2px solid var(--cardBorder); background:#0f151f;
      display:grid; place-items:center; cursor:pointer; user-select:none;
      transition:transform .12s ease, border-color .12s ease, background .12s ease;
      outline: none;
    }
    .card-tile:hover{ transform:translateY(-1px); border-color:var(--accent) }
    .card-tile:focus-visible{ box-shadow:0 0 0 3px rgba(78,205,196,.25); border-color:var(--accent) }

    .face{
      font-size:2rem; transform:scale(.85); opacity:0; transition:opacity .12s ease, transform .12s ease;
    }
    .flipped .face{ opacity:1; transform:scale(1) }
    .flipped{ background:linear-gradient(135deg, #0f151f, #203040); border-color:var(--accent) }

    .matched{
      background:var(--accent); border-color:var(--accent);
      animation: pulse .35s ease-in-out;
      color:#0b1020;
    }
    .matched .face{ opacity:1 }
    @keyframes pulse{ 0%,100%{ transform:scale(1)} 50%{ transform:scale(1.05)} }

    .peek .card-tile .face{ opacity:1; transform:scale(1) } /* peek phase shows all */
    .peek .card-tile{ border-color:rgba(255,255,255,.15) }
  </style>
</head>
<body>
  <div class="container">
    <div class="tool-header">
      <button id="backSmart" class="back-btn" type="button" aria-label="Back to games">‚Üê Back</button>
      <h1>üß† Memory Match</h1>
      <p>Flip cards and match pairs. How fast can you complete it?</p>
    </div>

    <div class="game-wrap">
      <section class="panel">
        <div class="hud" aria-live="polite">
          <div class="kpi"><div class="value" id="timer">00:00</div><div class="label">Time</div></div>
          <div class="kpi"><div class="value" id="moves">0</div><div class="label">Moves</div></div>
          <div class="kpi"><div class="value" id="pairs">0</div><div class="label">Pairs Found</div></div>
          <div class="kpi"><div class="value" id="best">--:--</div><div class="label">Best</div></div>
        </div>

        <div class="bar" role="toolbar" aria-label="Difficulty">
          <button class="difficulty-btn" data-level="easy">Easy (8 cards)</button>
          <button class="difficulty-btn" data-level="medium">Medium (18 cards)</button>
          <button class="difficulty-btn" data-level="hard">Hard (32 cards)</button>
        </div>

        <div id="status" class="status">Tap any card to start. You‚Äôll get a quick peek!</div>

        <div id="boardWrap" class="panel" style="padding:.75rem; margin-top:.75rem">
          <div id="grid" class="grid easy" role="grid" aria-label="Memory cards"></div>
        </div>

        <div class="controls">
          <button id="newGame" class="btn primary">New Game</button>
          <button id="resetBest" class="btn secondary">Reset Best Times</button>
        </div>
      </section>
    </div>
  </div>

  <script>
    (() => {
      // ---------- Utilities
      const $ = (s, el=document) => el.querySelector(s);
      const randInt = (n) => (Math.random() * n) | 0;

      // Smart back
      $("#backSmart").addEventListener("click", () => {
        if (history.length > 1) history.back();
        else window.location.href = "/games/?played=memory-match";
      });

      // WebAudio bleeps (no files)
      let audioCtx = null;
      const beep = (type="square", freq=440, ms=80, gain=0.025) => {
        try{
          audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); }, ms);
        }catch{}
      };
      const buzz = (ms=15) => { if (navigator.vibrate) navigator.vibrate(ms); };

      // ---------- Game
      class MemoryMatch {
        constructor(){
          // Emoji pool (>= 32 unique)
          this.pool = [
            "üçé","üçä","üçã","üçâ","üçá","üçì","üçí","üçç","ü•ù","ü•ë","ü•ï","üå∂Ô∏è","üçÑ","ü•®","üç™","üç∞",
            "üê∂","üê±","üê≠","üêπ","üê∞","ü¶ä","üêª","üêº","ü¶Å","üêØ","ü¶Ñ","üê∏","üêµ","üêô","üê†","ü¶ã"
          ];
          this.cfg = {
            easy:   { pairs: 4 },   // 8 cards
            medium: { pairs: 9 },   // 18 cards
            hard:   { pairs: 16 },  // 32 cards
          };

          // State
          this.level = localStorage.getItem("mem-level") || "easy";
          this.cards = [];       // [{id, symbol, el, matched}]
          this.flipped = [];     // [cardEl, cardEl]
          this.pairsFound = 0;
          this.moves = 0;
          this.peeking = false;
          this.locked = false;
          this.running = false;
          this.seconds = 0;
          this.tid = null;

          // DOM
          this.grid = $("#grid");
          this.timerEl = $("#timer");
          this.movesEl = $("#moves");
          this.pairsEl = $("#pairs");
          this.bestEl = $("#best");
          this.statusEl = $("#status");

          // Wire UI
          this.bindUI();
          this.setLevel(this.level);
          this.newGame(true); // initial render with peek
        }

        bindUI(){
          // Difficulty
          document.querySelectorAll(".difficulty-btn").forEach(btn=>{
            btn.addEventListener("click", () => this.setLevel(btn.dataset.level, btn));
          });
          // New game & reset best
          $("#newGame").addEventListener("click", () => this.newGame(true));
          $("#resetBest").addEventListener("click", () => this.resetBest());

          // Keyboard: Esc back to /games
          window.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              if (history.length > 1) history.back();
              else window.location.href = "/games/?played=memory-match";
            }
          });
        }

        setLevel(level, btn){
          if (!this.cfg[level]) level = "easy";
          this.level = level;
          localStorage.setItem("mem-level", level);
          // button state
          document.querySelectorAll(".difficulty-btn").forEach(b=>b.classList.remove("active"));
          const activeBtn = btn || document.querySelector(`.difficulty-btn[data-level="${level}"]`);
          if (activeBtn) activeBtn.classList.add("active");
          // grid class
          this.grid.className = "grid " + level;
          this.updateBestDisplay();
        }

        cardTemplate(id, symbol){
          const el = document.createElement("button");
          el.className = "card-tile";
          el.setAttribute("type","button");
          el.setAttribute("role","gridcell");
          el.setAttribute("aria-label","Hidden card");
          el.dataset.id = id;
          el.dataset.symbol = symbol;
          el.innerHTML = `<span class="face" aria-hidden="true">${symbol}</span>`;
          el.addEventListener("click", () => this.flip(el));
          el.addEventListener("keydown", (e)=> {
            if (e.key === " " || e.key === "Enter") { e.preventDefault(); this.flip(el); }
          });
          return el;
        }

        buildDeck(){
          const { pairs } = this.cfg[this.level];
          const symbols = [...this.pool].slice(0, pairs);
          const deck = [];
          let id = 0;
          for (const s of symbols){
            deck.push({ id:id++, symbol:s, matched:false });
            deck.push({ id:id++, symbol:s, matched:false });
          }
          // shuffle
          for (let i = deck.length - 1; i > 0; i--){
            const j = randInt(i+1);
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }
          return deck;
        }

        mountBoard(deck){
          this.grid.innerHTML = "";
          this.cards = deck.map(card => {
            const el = this.cardTemplate(card.id, card.symbol);
            this.grid.appendChild(el);
            return { ...card, el };
          });
          // focus first tile for keyboard users
          const first = this.grid.querySelector(".card-tile");
          if (first) first.focus({ preventScroll:true });
        }

        newGame(withPeek=false){
          this.stopTimer();
          this.seconds = 0; this.moves = 0; this.pairsFound = 0;
          this.flipped = []; this.locked = false; this.running = false;
          this.updateHUD();

          const deck = this.buildDeck();
          this.mountBoard(deck);

          // peek phase
          if (withPeek){
            this.statusEl.textContent = "Memorize the board‚Ä¶";
            document.body.classList.add("peek");
            this.cards.forEach(c => c.el.classList.add("flipped"));
            // reveal for a moment
            setTimeout(() => {
              document.body.classList.remove("peek");
              this.cards.forEach(c => c.el.classList.remove("flipped"));
              this.statusEl.textContent = "Go! Flip two cards to start the timer.";
              this.peeking = false;
            }, 1500);
            this.peeking = true;
          } else {
            this.statusEl.textContent = "Tap any card to start!";
          }
        }

        start(){
          if (this.running) return;
          this.running = true;
          this.tid = setInterval(()=>{ this.seconds++; this.updateHUD() }, 1000);
        }

        stopTimer(){
          if (this.tid){ clearInterval(this.tid); this.tid = null; }
          this.running = false;
        }

        flip(el){
          if (this.peeking || this.locked) return;
          if (el.classList.contains("matched") || el.classList.contains("flipped")) return;

          // first action starts timer
          if (!this.running) {
            this.start();
          }

          el.classList.add("flipped");
          el.setAttribute("aria-label","Revealed card");
          beep("triangle", 560, 50, .02);

          this.flipped.push(el);
          if (this.flipped.length === 2){
            this.moves++; this.updateHUD();
            this.checkMatch();
          }
        }

        checkMatch(){
          const [a, b] = this.flipped;
          const same = a.dataset.symbol === b.dataset.symbol;
          if (same){
            a.classList.add("matched"); b.classList.add("matched");
            this.pairsFound++;
            this.flipped = [];
            beep("sine", 760, 90, .03); buzz(12);
            this.updateHUD();
            if (this.pairsFound === this.cfg[this.level].pairs){
              this.finish();
            }
          } else {
            this.locked = true;
            beep("sawtooth", 220, 90, .025);
            setTimeout(()=>{
              a.classList.remove("flipped"); b.classList.remove("flipped");
              a.setAttribute("aria-label","Hidden card");
              b.setAttribute("aria-label","Hidden card");
              this.flipped = [];
              this.locked = false;
            }, 650);
          }
        }

        finish(){
          this.stopTimer();
          const t = this.formatTime(this.seconds);
          this.statusEl.innerHTML = `üéâ Completed in <b>${t}</b> with ${this.moves} moves!`;
          // best time
          const key = `mem-best-${this.level}`;
          const cur = +(localStorage.getItem(key) || 0);
          if (cur === 0 || this.seconds < cur){
            localStorage.setItem(key, String(this.seconds));
          }
          this.updateBestDisplay();
        }

        resetBest(){
          Object.keys(this.cfg).forEach(l => localStorage.removeItem(`mem-best-${l}`));
          this.updateBestDisplay();
          this.statusEl.textContent = "Best times reset. Good luck!";
        }

        updateBestDisplay(){
          const key = `mem-best-${this.level}`;
          const s = localStorage.getItem(key);
          this.bestEl.textContent = s ? this.formatTime(+s) : "--:--";
        }

        updateHUD(){
          this.timerEl.textContent = this.formatTime(this.seconds);
          this.movesEl.textContent = this.moves;
          this.pairsEl.textContent = this.pairsFound;
        }

        formatTime(sec){
          const m = Math.floor(sec/60), s = sec%60;
          return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
        }
      }

      // Boot
      new MemoryMatch();
    })();
  </script>
</body>
</html>
